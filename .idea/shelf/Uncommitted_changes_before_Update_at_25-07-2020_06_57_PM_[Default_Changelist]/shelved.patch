Index: exposure_enhancement.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport cv2\r\nfrom scipy.spatial import distance\r\nfrom scipy.ndimage.filters import convolve\r\nfrom scipy.sparse import diags, csr_matrix\r\nfrom scipy.sparse.linalg import spsolve\r\n# project\r\nfrom scipy import sparse\r\nfrom utils import get_sparse_neighbor\r\nfrom os import path\r\ncount = 0\r\n# TODO: Denoising images\r\ndef create_spacial_affinity_kernel(spatial_sigma: float, size: int = 15):\r\n    \"\"\"Create a kernel (`size` * `size` matrix) that will be used to compute the he spatial affinity based Gaussian\r\n    weights. Arguments: spatial_sigma {float} -- Spatial standard deviation. Keyword Arguments: size {int} -- size of\r\n    the kernel. (default: {15}) Returns: np.ndarray - `size` * `size` kernel\r\n    \"\"\"\r\n    kernel = np.zeros((size, size))\r\n    for i in range(size):\r\n        for j in range(size):\r\n            kernel[i, j] = np.exp(\r\n                 -0.5 * (distance.euclidean((i, j), (size // 2, size // 2)) ** 2) / (spatial_sigma ** 2))\r\n            #kernel[i, j] = (distance.euclidean((i, j), (size // 2, size // 2)) ** 2)\r\n    return kernel\r\n\r\n\r\ndef compute_smoothness_weights(L: np.ndarray, x: int, kernel: np.ndarray, eps: float = 1e-3):\r\n    \"\"\"Compute the smoothness weights used in refining the illumination map optimization problem.\r\n    Arguments:\r\n        L {np.ndarray} -- the initial illumination map to be refined.\r\n        x {int} -- the direction of the weights. Can either be x=1 for horizontal or x=0 for vertical.\r\n        kernel {np.ndarray} -- spatial affinity matrix\r\n    Keyword Arguments:\r\n        eps {float} -- small constant to avoid computation instability. (default: {1e-3})\r\n    Returns:\r\n        np.ndarray - smoothness weights according to direction x. same dimension as `L`.\r\n    \"\"\"\r\n    Lp = cv2.Sobel(L, cv2.CV_64F, int(x == 1), int(x == 0), ksize=1)\r\n    #weight=Lp*255\r\n    #output_illumination_map(weight)\r\n    T = convolve(np.ones_like(L), kernel, mode='constant')\r\n    #output_illumination_map(T)\r\n    T = T / (np.abs(convolve(Lp, kernel, mode='constant')) + eps)\r\n    #output_illumination_map(T)\r\n    #weight=(T / (np.abs(Lp) + eps))\r\n    #output_illumination_map(weight)\r\n    return T / (np.abs(Lp) + eps)\r\n\r\ndef fuse_multi_exposure_images(im: np.ndarray, under_ex: np.ndarray, over_ex: np.ndarray,\r\n                               bc: float = 1, bs: float = 1, be: float = 1):\r\n    \"\"\"perform the exposure fusion method used in the DUAL paper.\r\n    Arguments:\r\n        im {np.ndarray} -- input image to be enhanced.\r\n        under_ex {np.ndarray} -- under-exposure corrected image. same dimension as `im`.\r\n        over_ex {np.ndarray} -- over-exposure corrected image. same dimension as `im`.\r\n    Keyword Arguments:\r\n        bc {float} -- parameter for controlling the influence of Mertens's contrast measure. (default: {1})\r\n        bs {float} -- parameter for controlling the influence of Mertens's saturation measure. (default: {1})\r\n        be {float} -- parameter for controlling the influence of Mertens's well exposedness measure. (default: {1})\r\n    Returns:\r\n        np.ndarray -- the fused image. same dimension as `im`.\r\n    \"\"\"\r\n    merge_mertens = cv2.createMergeMertens(bc, bs, be)\r\n    images = [np.clip(x * 255, 0, 255).astype(\"uint8\") for x in [im, under_ex, over_ex]]\r\n    fused_images = merge_mertens.process(images)\r\n    return fused_images\r\n\r\n\r\ndef output_illumination_map(L_print: np.ndarray):\r\n    global count\r\n    count = count+1\r\n    cv2.imwrite('demo/enhanced/illumination_map{}.png'.format(count), L_print)\r\n\r\n\r\ndef refine_illumination_map_linear(L: np.ndarray, gamma: float, lambda_: float, kernel: np.ndarray, eps: float = 1e-3):\r\n    \"\"\"Refine the illumination map based on the optimization problem described in the two papers.\r\n       This function use the sped-up solver presented in the LIME paper.\r\n    Arguments:\r\n        L {np.ndarray} -- the illumination map to be refined.\r\n        gamma {float} -- gamma correction factor.\r\n        lambda_ {float} -- coefficient to balance the terms in the optimization problem.\r\n        kernel {np.ndarray} -- spatial affinity matrix.\r\n    Keyword Arguments:\r\n        eps {float} -- small constant to avoid computation instability (default: {1e-3}).\r\n    Returns:\r\n        np.ndarray -- refined illumination map. same shape as `L`.\r\n    \"\"\"\r\n    # kernel = create_spacial_affinity_kernel(7, 50)/255\r\n    # L_refined = cv2.filter2D(L, -1, kernel)\r\n    # compute smoothness weights\r\n    wx = compute_smoothness_weights(L, x=1, kernel=kernel, eps=eps)\r\n    wy = compute_smoothness_weights(L, x=0, kernel=kernel, eps=eps)\r\n\r\n    n, m = L.shape\r\n    L_1d = L.copy().flatten()\r\n\r\n    # compute the five-point spatially inhomogeneous Laplacian matrix\r\n    row, column, data = [], [], []\r\n    for p in range(n * m):\r\n        diag = 0\r\n        for q, (k, l, x) in get_sparse_neighbor(p, n, m).items():\r\n            weight = wx[k, l] if x else wy[k, l]\r\n            row.append(p)\r\n            column.append(q)\r\n            data.append(-weight)\r\n            diag += weight\r\n        row.append(p)\r\n        column.append(p)\r\n        data.append(diag)\r\n    F = csr_matrix((data, (row, column)), shape=(n * m, n * m))\r\n    # solve the linear system\r\n    Id = diags([np.ones(n * m)], [0])\r\n    A = Id + lambda_ * F\r\n    L_refined = spsolve(csr_matrix(A), L_1d, permc_spec=None, use_umfpack=True).reshape((n, m))\r\n    # gamma correction\r\n    L_refined = np.clip(L_refined, eps, 1) ** gamma\r\n    L_print = L_refined * 255\r\n    #output_illumination_map(L_print)\r\n    #check\r\n    return L_refined\r\n\r\n\r\ndef correct_underexposure(im: np.ndarray, gamma: float, lambda_: float, kernel: np.ndarray, eps: float = 1e-3):\r\n    \"\"\"correct underexposudness using the retinex based algorithm presented in DUAL and LIME paper.\r\n    Arguments:\r\n        im {np.ndarray} -- input image to be corrected.\r\n        gamma {float} -- gamma correction factor.\r\n        lambda_ {float} -- coefficient to balance the terms in the optimization problem.\r\n        kernel {np.ndarray} -- spatial affinity matrix.\r\n    Keyword Arguments:\r\n        eps {float} -- small constant to avoid computation instability (default: {1e-3})\r\n    Returns:\r\n        np.ndarray -- image underexposudness corrected. same shape as `im`.\r\n    \"\"\"\r\n\r\n    # first estimation of the illumination map\r\n    L = np.max(im, axis=-1)\r\n    L_print = L*255\r\n    output_illumination_map(L_print)\r\n    # illumination refinement\r\n    L_refined = refine_illumination_map_linear(L, gamma, lambda_, kernel, eps)\r\n    # correct image underexposure\r\n    #L_refined = cv2.bilateralFilter(L_print, 8, 500, 500)\r\n    L_refined_3d = np.repeat(L_refined[..., None], 3, axis=-1)\r\n    L_print2 = L_refined_3d*255\r\n    output_illumination_map(L_print2)\r\n    im_corrected = im / L_refined_3d\r\n    return im_corrected\r\n\r\n\r\n# TODO: resize image if too large, optimization take too much time\r\n\r\n\r\ndef enhance_image_exposure(im: np.ndarray, gamma: float, lambda_: float, dual: bool = True, sigma: int = 3,\r\n                           bc: float = 1, bs: float = 1, be: float = 1, eps: float = 1e-3):\r\n    \"\"\"Enhance input image, using either DUAL method, or LIME method. For more info, please see original papers.\r\n    Arguments:\r\n        im {np.ndarray} -- input image to be corrected.\r\n        gamma {float} -- gamma correction factor.\r\n        lambda_ {float} -- coefficient to balance the terms in the optimization problem (in DUAL and LIME).\r\n    Keyword Arguments:\r\n        dual {bool} -- boolean variable to indicate enhancement method to be used (either DUAL or LIME) (default: {True})\r\n        sigma {int} -- Spatial standard deviation for spatial affinity based Gaussian weights. (default: {3})\r\n        bc {float} -- parameter for controlling the influence of Mertens's contrast measure. (default: {1})\r\n        bs {float} -- parameter for controlling the influence of Mertens's saturation measure. (default: {1})\r\n        be {float} -- parameter for controlling the influence of Mertens's well exposedness measure. (default: {1})\r\n        eps {float} -- small constant to avoid computation instability (default: {1e-3})\r\n    Returns:\r\n        np.ndarray -- image exposure enhanced. same shape as `im`.\r\n    \"\"\"\r\n    # create spacial affinity kernel\r\n    kernel = create_spacial_affinity_kernel(sigma)\r\n\r\n    # correct underexposudness\r\n    im_normalized = im.astype(float) / 255.\r\n    under_corrected = correct_underexposure(im_normalized, gamma, lambda_, kernel, eps)\r\n\r\n    if dual:\r\n        # correct overexposure and merge if DUAL method is selected\r\n        inv_im_normalized = 1 - im_normalized\r\n        over_corrected = 1 - correct_underexposure(inv_im_normalized, gamma, lambda_, kernel, eps)\r\n        # fuse images\r\n        im_corrected = fuse_multi_exposure_images(im_normalized, under_corrected, over_corrected, bc, bs, be)\r\n    else:\r\n        im_corrected = under_corrected\r\n\r\n    # convert to 8 bits and returns\r\n    return np.clip(im_corrected * 255, 0, 255).astype(\"uint8\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- exposure_enhancement.py	(revision 8fb631a68a5524b442e98e3ddf68172f7cb00b3f)
+++ exposure_enhancement.py	(date 1595683616986)
@@ -149,7 +149,8 @@
 
 
 # TODO: resize image if too large, optimization take too much time
-
+def denoising_img(noisy_image):
+    return cv2.fastNlMeansDenoisingColored(noisy_image, None, 10, 10, 5, 7)
 
 def enhance_image_exposure(im: np.ndarray, gamma: float, lambda_: float, dual: bool = True, sigma: int = 3,
                            bc: float = 1, bs: float = 1, be: float = 1, eps: float = 1e-3):
@@ -170,7 +171,6 @@
     """
     # create spacial affinity kernel
     kernel = create_spacial_affinity_kernel(sigma)
-
     # correct underexposudness
     im_normalized = im.astype(float) / 255.
     under_corrected = correct_underexposure(im_normalized, gamma, lambda_, kernel, eps)
@@ -183,6 +183,6 @@
         im_corrected = fuse_multi_exposure_images(im_normalized, under_corrected, over_corrected, bc, bs, be)
     else:
         im_corrected = under_corrected
-
-    # convert to 8 bits and returns
-    return np.clip(im_corrected * 255, 0, 255).astype("uint8")
+    #noisy_img = np.clip(im_corrected * 255, 0, 255).astype("uint8")
+    #return denoising_img(noisy_img)
+    return np.clip(im_corrected * 255, 0, 255)
Index: demo.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import argparse\r\nfrom argparse import RawTextHelpFormatter\r\nimport glob\r\nfrom os import makedirs\r\nfrom os.path import join, exists, basename, splitext\r\n# 3p\r\nimport cv2\r\nfrom tqdm import tqdm\r\n# project\r\nfrom exposure_enhancement import enhance_image_exposure\r\n# TODO: Add function to check if enhanced image exits and skip that file\r\n\r\ndef main(args):\r\n    # load images\r\n    imdir = args.folder\r\n    ext = ['png', 'jpg', 'bmp']    # Add image formats here\r\n    files = []\r\n    [files.extend(glob.glob(imdir + '*.' + e)) for e in ext]\r\n    images = [cv2.imread(file) for file in files]\r\n\r\n    # create save directory\r\n    directory = join(imdir, \"enhanced\")\r\n    if not exists(directory):\r\n        makedirs(directory)\r\n\r\n    # enhance images\r\n    for i, image in tqdm(enumerate(images), desc=\"Enhancing images\"):\r\n        enhanced_image = enhance_image_exposure(image, args.gamma, args.lambda_, not args.lime,\r\n                                                sigma=args.sigma, bc=args.bc, bs=args.bs, be=args.be, eps=args.eps)\r\n        filename = basename(files[i])\r\n        name, ext = splitext(filename)\r\n        method = \"LIME\" if args.lime else \"DUAL\"\r\n        corrected_name = f\"{name}_{method}_g{args.gamma}_l{args.lambda_}{ext}\"\r\n        cv2.imwrite(join(directory, corrected_name), enhanced_image)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    parser = argparse.ArgumentParser(\r\n        description=\"Python implementation of two low-light image enhancement techniques via illumination map \"\r\n                    \"estimation.\",\r\n        formatter_class=RawTextHelpFormatter\r\n    )\r\n    parser.add_argument(\"-f\", '--folder', default='./demo/', type=str,\r\n                        help=\"folder path to test images.\")\r\n    parser.add_argument(\"-g\", '--gamma', default=0.6, type=float,\r\n                        help=\"the gamma correction parameter.\")\r\n    parser.add_argument(\"-l\", '--lambda_', default=0.1, type=float,\r\n                        help=\"the weight for balancing the two terms in the illumination refinement optimization objective.\")\r\n    parser.add_argument(\"-ul\", \"--lime\", action='store_true',\r\n                        help=\"Use the LIME method. By default, the DUAL method is used.\")\r\n    parser.add_argument(\"-s\", '--sigma', default=3, type=int,\r\n                        help=\"Spatial standard deviation for spatial affinity based Gaussian weights.\")\r\n    parser.add_argument(\"-bc\", default=1, type=float,\r\n                        help=\"parameter for controlling the influence of Mertens's contrast measure.\")\r\n    parser.add_argument(\"-bs\", default=1, type=float,\r\n                        help=\"parameter for controlling the influence of Mertens's saturation measure.\")\r\n    parser.add_argument(\"-be\", default=1, type=float,\r\n                        help=\"parameter for controlling the influence of Mertens's well exposedness measure.\")\r\n    parser.add_argument(\"-eps\", default=1e-3, type=float,\r\n                        help=\"constant to avoid computation instability.\")\r\n\r\n    args = parser.parse_args()\r\n    main(args)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo.py	(revision 8fb631a68a5524b442e98e3ddf68172f7cb00b3f)
+++ demo.py	(date 1595682786223)
@@ -8,16 +8,16 @@
 from tqdm import tqdm
 # project
 from exposure_enhancement import enhance_image_exposure
+from PIL import Image
 # TODO: Add function to check if enhanced image exits and skip that file
 
 def main(args):
     # load images
     imdir = args.folder
-    ext = ['png', 'jpg', 'bmp']    # Add image formats here
+    ext = ['png', 'jpg', 'bmp', 'jpeg']    # Add image formats here
     files = []
     [files.extend(glob.glob(imdir + '*.' + e)) for e in ext]
     images = [cv2.imread(file) for file in files]
-
     # create save directory
     directory = join(imdir, "enhanced")
     if not exists(directory):
@@ -25,6 +25,10 @@
 
     # enhance images
     for i, image in tqdm(enumerate(images), desc="Enhancing images"):
+        #print(type(image))
+        #width, height, channel = image.shape
+        #if width > 600 and height > 400:
+        #    image.resize((600, 400))
         enhanced_image = enhance_image_exposure(image, args.gamma, args.lambda_, not args.lime,
                                                 sigma=args.sigma, bc=args.bc, bs=args.bs, be=args.be, eps=args.eps)
         filename = basename(files[i])
